{
    "componentChunkName": "component---src-templates-template-js",
    "path": "/design-patterns/gof",
    "result": {"data":{"markdownRemark":{"html":"<p>Design patterns gained popularity in computer science after the book Design Patterns: Elements of Reusable Object-Oriented Software was published in 1994 by the so-called \"Gang of Four\" (Erich Gamma, Richard Helm, Ralph Johnson and John Vlissides)</p>\n<p>There are 23 design patterns which can be classified in three categories:</p>\n<ul>\n<li><strong>Creational Patterns</strong>: deal with the process of object creation</li>\n<li><strong>Structural Patterns</strong>: deal with the composition of classes or objects</li>\n<li><strong>Behavioral Patterns</strong>: characterize the ways in which classes or objects interact and distribute responsibility</li>\n</ul>\n<h2 id=\"creational-patterns\" style=\"position:relative;\"><a href=\"#creational-patterns\" aria-label=\"creational patterns permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Creational Patterns</h2>\n<ul>\n<li><strong>Abstract Factory</strong>: Provide an interface for creating families of related or dependent objects without specifying their concrete classes.</li>\n<li><strong>Builder</strong>: Separate the construction of a complex object from its representation so that the same construction process can create different representations</li>\n<li><strong>Factory Method</strong>: Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.</li>\n<li><strong>Prototype</strong>: Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.</li>\n<li><strong>Singleton</strong>: Ensure a class only has one instance, and provide a global point of access to it.</li>\n</ul>\n<h2 id=\"structural-patterns\" style=\"position:relative;\"><a href=\"#structural-patterns\" aria-label=\"structural patterns permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Structural Patterns</h2>\n<ul>\n<li><strong>Bridge</strong>: Decouple an abstraction from its implementation so that the two can vary independently.</li>\n<li><strong>Adapter</strong>: Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces.</li>\n<li><strong>Composite</strong>: Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.</li>\n<li><strong>Decorator</strong>: Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.</li>\n<li><strong>Facade</strong>: Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.</li>\n<li><strong>Flyweight</strong>: Use sharing to support large numbers of fine-grained objects efficiently.</li>\n<li><strong>Proxy</strong>: Provide a surrogate or placeholder for another object to control access to it.</li>\n</ul>\n<h2 id=\"behavioral-patterns\" style=\"position:relative;\"><a href=\"#behavioral-patterns\" aria-label=\"behavioral patterns permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Behavioral Patterns</h2>\n<ul>\n<li><strong>Chain of Responsibility</strong>: Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.</li>\n<li><strong>Command</strong>: Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.</li>\n<li><strong>Interpreter</strong>: Given a language, define a represention for its grammar along with an interpreter that uses the representation to interpret sentences in the language.</li>\n<li><strong>Iterator</strong>: Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.</li>\n<li><strong>Mediator</strong>: Define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently.</li>\n<li><strong>Memento</strong>: Without violating encapsulation, capture and externalize an object’s internal state so that the object can be restored to this state later.</li>\n<li><strong>Observer</strong>: Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.</li>\n<li><strong>State</strong>: Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.</li>\n<li><strong>Strategy</strong>: Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.</li>\n<li><strong>Template Method</strong>: Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.</li>\n<li><strong>Visitor</strong>: Represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates.</li>\n</ul>","frontmatter":{"slug":"/design-patterns/gof","title":"Gang of Four Design Patterns","course":"Programming Project 2021/22","previous":"/design-patterns/introduction","next":null,"chapter":15,"section":3,"module":"Design Patterns","banner":null}}},"pageContext":{"slug":"/design-patterns/gof"}},
    "staticQueryHashes": ["800307450"]}